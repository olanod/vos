#![feature(iter_array_chunks)]
#![feature(impl_trait_in_assoc_type)]
#![allow(async_fn_in_trait)]
#![cfg_attr(not(test), no_std)]

// although we include alloc core OS components should avoid doing allocations
extern crate alloc;

// #[cfg(feature = "std")]
// extern crate std;

#[cfg(feature = "rv")]
#[global_allocator]
static HEAP: embedded_alloc::LlffHeap = embedded_alloc::LlffHeap::empty();
#[cfg(feature = "std")]
#[global_allocator]
static HEAP: mimalloc::MiMalloc = mimalloc::MiMalloc;

use core::str::FromStr;
use embassy_executor::{Executor, SendSpawner, SpawnToken};
use embassy_sync::{mutex::Mutex, once_lock::OnceLock};
use embassy_time as _;
use futures_concurrency::future::Race;
use miniserde::Deserialize;
use static_cell::{ConstStaticCell, StaticCell};
use types::*;

static RNG: OnceLock<Mutex<types::RawMutex, Rng>> = OnceLock::new();
pub async fn rng() -> Rng {
    let mut rng = RNG.get().await.lock().await;
    <Rng as rand::SeedableRng>::from_rng(&mut *rng).expect("rng from os::RNG")
}

pub mod pacman;
pub mod ports;
mod sensors;
pub mod shell;
mod types;
pub mod vm;

pub mod net {
    pub use core::net::*;
    pub use edge_net::*;
    use nal::{TcpAccept, TcpBind};
    mod dummy;

    #[cfg(feature = "std")]
    pub type Stack = edge_net::std::Stack;
    #[cfg(not(feature = "std"))]
    pub type Stack = dummy::Stack; // TODO
    pub type TcpConnection = <Stack as TcpBind>::Accept<'static>;
    pub type TcpSocket = <TcpConnection as TcpAccept>::Socket<'static>;

    pub const STACK: Stack = Stack::new();
    pub const fn stack() -> &'static Stack {
        &STACK
    }

    pub async fn bind(port: u16) -> Result<TcpConnection, ()> {
        pub const ADDR: [u8; 4] = [0, 0, 0, 0];
        log::debug!("Listening on port {port}");
        stack().bind((ADDR, port).into()).await.map_err(|_| ())
    }
}

/// OS groups and wires together the commponents that make up the embedded OS
/// it sets up resources and runs forever waiting for connections
/// to start interactive sessions that run installed applications for a given user
pub struct Os {
    sys_ports: Worker,
    vm: Worker,
}

impl Os {
    // pub fn boot(cfg: Config) -> &'static Self {
    pub fn boot(cfg: SystemConfig) {
        static OS: StaticCell<Os> = StaticCell::new();
        let os = OS.init(Os {
            sys_ports: Worker::new(),
            vm: Worker::new(),
        });
        log::debug!("Booting up");
        log::trace!("Seeding randomness");
        RNG.init(Mutex::new(<Rng as rand::SeedableRng>::from_seed([0; 32])))
            .expect("rng seeded");

        static ACTION_CH: ConstStaticCell<Channel<(DataTy, Pipe)>> =
            ConstStaticCell::new(Channel::new());
        let action_ch = ACTION_CH.take();

        os.sys_ports
            .run(|s| ports::handle_connections(s, cfg.system_ports));
        os.vm.run(|s| vm::run(s, cfg.vm, action_ch.receiver()));
        // os
    }
}

/// Sensors produce pieces of readable data from external sources,
/// like user input, to be consumed by the system planer and posibly
/// dispatched to one or multiple actuators
pub trait Sensor {
    async fn ready(&self) -> Datum;
}

#[derive(Clone)]
pub enum DataTy {
    // A direct request to execute a specific action
    Action(Action), // TODO flags here as well?
    Script,
    Prompt,
}

/// Datum is a piece of readable data generated by a sensor
pub struct Datum {
    pub descriptor: Descriptor,
    stream: Option<Pipe>,
    pub ty: DataTy,
}
impl Datum {
    pub fn new(pipe: Pipe, ty: DataTy) -> Self {
        Self {
            descriptor: 0,
            stream: Some(pipe),
            ty,
        }
    }
    pub fn consume(&mut self) -> Option<(DataTy, Pipe)> {
        self.stream.take().map(|s| (self.ty.clone(), s))
    }
    pub fn consumed(&self) -> bool {
        self.stream.is_none()
    }
}

/// An actuator is a collection of concrete actions to be executed by a planner
pub trait Actuator {
    async fn execute(&mut self, action: &Action, input: Pipe) -> Result<(), ()>;
}

/// Planer orchestrates what actions should be taken based
/// on sensor data or other internal mechanisms
pub struct Planner<const N: usize> {
    sensors: [OsSensor; N],
}

impl<const N: usize> Planner<N> {
    pub const fn new(sensors: [OsSensor; N]) -> Self {
        Self { sensors }
    }

    // async fn plan(&self);

    pub async fn run(&mut self) {
        loop {
            let d = self.poll_sensors().await;
            match d.ty {
                DataTy::Action(_action) => {}
                DataTy::Script => {
                    log::debug!("not implemented")
                }
                DataTy::Prompt => {
                    log::debug!("not implemented")
                }
            }
        }
    }

    async fn poll_sensors(&mut self) -> Datum {
        let data: [_; N] = core::array::from_fn(|i| self.sensors[i].ready());
        data.race().await
    }
}

#[derive(Deserialize)]
pub struct SystemConfig {
    /// System service that can handle authentication
    pub auth_action: CfgString,
    pub system_ports: ports::Config,
    pub vm: vm::Config,
}
impl Default for SystemConfig {
    fn default() -> Self {
        SystemConfig {
            auth_action: CfgString(Action::from_str("auth").unwrap()),
            system_ports: Default::default(),
            vm: Default::default(),
        }
    }
}

pub struct Worker {
    exec: Executor,
}
impl Worker {
    fn new() -> Self {
        Worker {
            exec: Executor::new(),
        }
    }

    fn run<T, S>(&'static mut self, task: T)
    where
        T: FnOnce(SendSpawner) -> SpawnToken<S>,
    {
        #[cfg(not(feature = "web"))]
        self.exec.run(|s| s.must_spawn(task(s.make_send())));
        #[cfg(feature = "web")]
        self.exec.start(|s| s.must_spawn(task(s.make_send())));
    }
}
